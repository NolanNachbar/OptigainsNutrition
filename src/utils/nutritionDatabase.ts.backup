// Removed direct supabase import - using database abstraction instead
import {
  UserNutritionProfile,
  Food,
  Meal,
  NutritionLog,
  WeightEntry,
  QuickAddFood,
  MealTemplate,
  WeeklyCheckIn,
  Macros,
  MealType
} from './types';

// ========== User Profile Operations ==========

export async function getUserProfile(userId: string): Promise<UserNutritionProfile | null> {
  const { data, error } = await supabase
    .from('user_nutrition_profiles')
    .select('*')
    .eq('clerk_user_id', userId)
    .single();

  if (error) {
    console.error('Error fetching user profile:', error);
    return null;
  }

  // Convert database format to TypeScript interface
  if (data) {
    return {
      ...data,
      target_macros: {
        calories: data.target_calories,
        protein: data.target_protein,
        carbs: data.target_carbs,
        fat: data.target_fat,
        fiber: data.target_fiber
      }
    };
  }

  return null;
}

export async function createOrUpdateUserProfile(profile: UserNutritionProfile): Promise<boolean> {
  const { target_macros, ...rest } = profile;
  
  const dbProfile = {
    ...rest,
    target_calories: target_macros.calories,
    target_protein: target_macros.protein,
    target_carbs: target_macros.carbs,
    target_fat: target_macros.fat,
    target_fiber: target_macros.fiber
  };

  const { error } = await supabase
    .from('user_nutrition_profiles')
    .upsert(dbProfile, { onConflict: 'clerk_user_id' });

  if (error) {
    console.error('Error updating user profile:', error);
    return false;
  }

  return true;
}

// ========== Food Operations ==========

export async function searchFoods(query: string, userId?: string): Promise<Food[]> {
  // Search both public foods and user's custom foods
  const { data, error } = await supabase
    .from('foods')
    .select('*')
    .or(`clerk_user_id.is.null,clerk_user_id.eq.${userId}`)
    .ilike('name', `%${query}%`)
    .limit(20);

  if (error) {
    console.error('Error searching foods:', error);
    return [];
  }

  return data || [];
}

export async function getFoodById(foodId: string): Promise<Food | null> {
  const { data, error } = await supabase
    .from('foods')
    .select('*')
    .eq('id', foodId)
    .single();

  if (error) {
    console.error('Error fetching food:', error);
    return null;
  }

  return data;
}

export async function createFood(food: Omit<Food, 'id' | 'created_at'>): Promise<Food | null> {
  const { data, error } = await supabase
    .from('foods')
    .insert(food)
    .select()
    .single();

  if (error) {
    console.error('Error creating food:', error);
    return null;
  }

  return data;
}

export async function updateFood(foodId: string, updates: Partial<Food>): Promise<boolean> {
  const { error } = await supabase
    .from('foods')
    .update(updates)
    .eq('id', foodId);

  if (error) {
    console.error('Error updating food:', error);
    return false;
  }

  return true;
}

export async function deleteFood(foodId: string): Promise<boolean> {
  const { error } = await supabase
    .from('foods')
    .delete()
    .eq('id', foodId);

  if (error) {
    console.error('Error deleting food:', error);
    return false;
  }

  return true;
}

// ========== Meal Operations ==========

export async function getMealsByDate(userId: string, date: string): Promise<Meal[]> {
  const startOfDay = `${date}T00:00:00`;
  const endOfDay = `${date}T23:59:59`;

  const { data, error } = await supabase
    .from('meals')
    .select(`
      *,
      food:foods(*)
    `)
    .eq('clerk_user_id', userId)
    .gte('logged_at', startOfDay)
    .lte('logged_at', endOfDay)
    .order('logged_at');

  if (error) {
    console.error('Error fetching meals:', error);
    return [];
  }

  return data || [];
}

export async function addMeal(meal: Omit<Meal, 'id' | 'created_at'>): Promise<Meal | null> {
  const { data, error } = await supabase
    .from('meals')
    .insert({
      clerk_user_id: meal.clerk_user_id,
      food_id: meal.food_id,
      amount_grams: meal.amount_grams,
      meal_type: meal.meal_type,
      logged_at: meal.logged_at,
      notes: meal.notes
    })
    .select(`
      *,
      food:foods(*)
    `)
    .single();

  if (error) {
    console.error('Error adding meal:', error);
    return null;
  }

  return data;
}

export async function updateMeal(mealId: string, updates: Partial<Meal>): Promise<boolean> {
  const { error } = await supabase
    .from('meals')
    .update(updates)
    .eq('id', mealId);

  if (error) {
    console.error('Error updating meal:', error);
    return false;
  }

  return true;
}

export async function deleteMeal(mealId: string): Promise<boolean> {
  const { error } = await supabase
    .from('meals')
    .delete()
    .eq('id', mealId);

  if (error) {
    console.error('Error deleting meal:', error);
    return false;
  }

  return true;
}

export async function copyMealsFromDate(userId: string, fromDate: string, toDate: string): Promise<boolean> {
  // Get meals from the source date
  const meals = await getMealsByDate(userId, fromDate);
  
  if (meals.length === 0) {
    return false;
  }

  // Copy each meal to the new date
  const newMeals = meals.map(meal => ({
    clerk_user_id: userId,
    food_id: meal.food_id,
    amount_grams: meal.amount_grams,
    meal_type: meal.meal_type,
    logged_at: `${toDate}T${meal.logged_at.split('T')[1]}`,
    notes: meal.notes
  }));

  const { error } = await supabase
    .from('meals')
    .insert(newMeals);

  if (error) {
    console.error('Error copying meals:', error);
    return false;
  }

  return true;
}

// ========== Nutrition Log Operations ==========

export async function getNutritionLog(userId: string, date: string): Promise<NutritionLog | null> {
  const { data, error } = await supabase
    .from('nutrition_logs')
    .select('*')
    .eq('clerk_user_id', userId)
    .eq('date', date)
    .single();

  if (error && error.code !== 'PGRST116') { // Not found is ok
    console.error('Error fetching nutrition log:', error);
  }

  return data || null;
}

export async function getNutritionLogRange(
  userId: string, 
  startDate: string, 
  endDate: string
): Promise<NutritionLog[]> {
  const { data, error } = await supabase
    .from('nutrition_logs')
    .select('*')
    .eq('clerk_user_id', userId)
    .gte('date', startDate)
    .lte('date', endDate)
    .order('date', { ascending: false });

  if (error) {
    console.error('Error fetching nutrition logs:', error);
    return [];
  }

  return data || [];
}

export async function updateNutritionLog(
  userId: string, 
  date: string, 
  updates: Partial<NutritionLog>
): Promise<boolean> {
  const { error } = await supabase
    .from('nutrition_logs')
    .upsert({
      clerk_user_id: userId,
      date,
      ...updates
    }, { onConflict: 'clerk_user_id,date' });

  if (error) {
    console.error('Error updating nutrition log:', error);
    return false;
  }

  return true;
}

// ========== Weight Operations ==========

export async function getWeightEntries(
  userId: string, 
  limit: number = 30
): Promise<WeightEntry[]> {
  const { data, error } = await supabase
    .from('weight_entries')
    .select('*')
    .eq('clerk_user_id', userId)
    .order('date', { ascending: false })
    .limit(limit);

  if (error) {
    console.error('Error fetching weight entries:', error);
    return [];
  }

  return data || [];
}

export async function getWeightRange(
  userId: string,
  startDate: string,
  endDate: string
): Promise<WeightEntry[]> {
  const { data, error } = await supabase
    .from('weight_entries')
    .select('*')
    .eq('clerk_user_id', userId)
    .gte('date', startDate)
    .lte('date', endDate)
    .order('date');

  if (error) {
    console.error('Error fetching weight range:', error);
    return [];
  }

  return data || [];
}

export async function addWeightEntry(entry: Omit<WeightEntry, 'id' | 'created_at'>): Promise<boolean> {
  const { error } = await supabase
    .from('weight_entries')
    .upsert({
      clerk_user_id: entry.clerk_user_id,
      date: entry.date,
      weight: entry.weight,
      body_fat_percentage: entry.body_fat_percentage,
      notes: entry.notes
    }, { onConflict: 'clerk_user_id,date' });

  if (error) {
    console.error('Error adding weight entry:', error);
    return false;
  }

  // Also update the nutrition log for that day
  await updateNutritionLog(entry.clerk_user_id, entry.date, { weight: entry.weight });

  return true;
}

// ========== Quick Add Foods Operations ==========

export async function getQuickAddFoods(userId: string, limit: number = 20): Promise<QuickAddFood[]> {
  const { data, error } = await supabase
    .from('quick_add_foods')
    .select(`
      *,
      food:foods(*)
    `)
    .eq('clerk_user_id', userId)
    .order('frequency', { ascending: false })
    .limit(limit);

  if (error) {
    console.error('Error fetching quick add foods:', error);
    return [];
  }

  return data || [];
}

export async function getFavoriteFoods(userId: string): Promise<QuickAddFood[]> {
  const { data, error } = await supabase
    .from('quick_add_foods')
    .select(`
      *,
      food:foods(*)
    `)
    .eq('clerk_user_id', userId)
    .eq('is_favorite', true)
    .order('last_used', { ascending: false });

  if (error) {
    console.error('Error fetching favorite foods:', error);
    return [];
  }

  return data || [];
}

export async function toggleFavoriteFood(userId: string, foodId: string): Promise<boolean> {
  // First check if it exists
  const { data: existing } = await supabase
    .from('quick_add_foods')
    .select('is_favorite')
    .eq('clerk_user_id', userId)
    .eq('food_id', foodId)
    .single();

  if (existing) {
    // Toggle the favorite status
    const { error } = await supabase
      .from('quick_add_foods')
      .update({ is_favorite: !existing.is_favorite })
      .eq('clerk_user_id', userId)
      .eq('food_id', foodId);

    if (error) {
      console.error('Error toggling favorite:', error);
      return false;
    }
  } else {
    // Create new favorite
    const { error } = await supabase
      .from('quick_add_foods')
      .insert({
        clerk_user_id: userId,
        food_id: foodId,
        is_favorite: true,
        frequency: 0
      });

    if (error) {
      console.error('Error creating favorite:', error);
      return false;
    }
  }

  return true;
}

// ========== Meal Template Operations ==========

export async function getMealTemplates(userId: string): Promise<MealTemplate[]> {
  const { data, error } = await supabase
    .from('meal_templates')
    .select('*')
    .eq('clerk_user_id', userId)
    .order('created_at', { ascending: false });

  if (error) {
    console.error('Error fetching meal templates:', error);
    return [];
  }

  return data?.map((template: any) => ({
    ...template,
    total_macros: {
      calories: template.total_calories,
      protein: template.total_protein,
      carbs: template.total_carbs,
      fat: template.total_fat,
      fiber: template.total_fiber
    }
  })) || [];
}

export async function createMealTemplate(template: Omit<MealTemplate, 'id' | 'created_at'>): Promise<boolean> {
  const { total_macros, ...rest } = template;
  
  const { error } = await supabase
    .from('meal_templates')
    .insert({
      ...rest,
      clerk_user_id: template.clerk_user_id,
      total_calories: total_macros.calories,
      total_protein: total_macros.protein,
      total_carbs: total_macros.carbs,
      total_fat: total_macros.fat,
      total_fiber: total_macros.fiber
    });

  if (error) {
    console.error('Error creating meal template:', error);
    return false;
  }

  return true;
}

export async function applyMealTemplate(
  userId: string, 
  templateId: string, 
  date: string, 
  mealType: MealType
): Promise<boolean> {
  // Get the template
  const { data: template, error: templateError } = await supabase
    .from('meal_templates')
    .select('*')
    .eq('id', templateId)
    .single();

  if (templateError || !template) {
    console.error('Error fetching template:', templateError);
    return false;
  }

  // Create meals from template
  const meals = template.foods.map((food: any) => ({
    clerk_user_id: userId,
    food_id: food.food_id,
    amount_grams: food.amount_grams,
    meal_type: mealType,
    logged_at: `${date}T${new Date().toISOString().split('T')[1]}`
  }));

  const { error } = await supabase
    .from('meals')
    .insert(meals);

  if (error) {
    console.error('Error applying template:', error);
    return false;
  }

  return true;
}

// ========== Weekly Check-in Operations ==========

export async function getLatestCheckIn(userId: string): Promise<WeeklyCheckIn | null> {
  const { data, error } = await supabase
    .from('weekly_check_ins')
    .select('*')
    .eq('clerk_user_id', userId)
    .order('week_start_date', { ascending: false })
    .limit(1)
    .single();

  if (error && error.code !== 'PGRST116') {
    console.error('Error fetching check-in:', error);
  }

  if (data) {
    return {
      ...data,
      average_macros: {
        calories: data.average_calories,
        protein: data.average_protein,
        carbs: data.average_carbs,
        fat: data.average_fat
      }
    };
  }

  return null;
}

export async function createWeeklyCheckIn(checkIn: Omit<WeeklyCheckIn, 'id' | 'created_at'>): Promise<boolean> {
  const { average_macros, ...rest } = checkIn;
  
  const dbCheckIn = {
    ...rest,
    clerk_user_id: checkIn.clerk_user_id,
    average_calories: average_macros.calories,
    average_protein: average_macros.protein,
    average_carbs: average_macros.carbs,
    average_fat: average_macros.fat
  };

  const { error } = await supabase
    .from('weekly_check_ins')
    .insert(dbCheckIn);

  if (error) {
    console.error('Error creating check-in:', error);
    return false;
  }

  return true;
}

// ========== Calculation Functions ==========

export async function calculateDailyTotals(userId: string, date: string): Promise<Macros> {
  const meals = await getMealsByDate(userId, date);
  
  return meals.reduce((totals, meal) => {
    if (!meal.food) return totals;
    
    const multiplier = meal.amount_grams / 100;
    return {
      calories: totals.calories + (meal.food.calories_per_100g * multiplier),
      protein: totals.protein + (meal.food.protein_per_100g * multiplier),
      carbs: totals.carbs + (meal.food.carbs_per_100g * multiplier),
      fat: totals.fat + (meal.food.fat_per_100g * multiplier),
      fiber: (totals.fiber || 0) + ((meal.food.fiber_per_100g || 0) * multiplier),
      sugar: (totals.sugar || 0) + ((meal.food.sugar_per_100g || 0) * multiplier),
      saturatedFat: (totals.saturatedFat || 0) + ((meal.food.saturated_fat_per_100g || 0) * multiplier)
    };
  }, { calories: 0, protein: 0, carbs: 0, fat: 0, fiber: 0, sugar: 0, saturatedFat: 0 });
}

export async function calculateWeeklyAverages(
  userId: string, 
  endDate: string
): Promise<{ macros: Macros, adherence: number }> {
  const startDate = new Date(endDate);
  startDate.setDate(startDate.getDate() - 6);
  
  const logs = await getNutritionLogRange(
    userId, 
    startDate.toISOString().split('T')[0], 
    endDate
  );

  if (logs.length === 0) {
    return {
      macros: { calories: 0, protein: 0, carbs: 0, fat: 0 },
      adherence: 0
    };
  }

  const totals = logs.reduce((acc, log) => ({
    calories: acc.calories + log.calories,
    protein: acc.protein + log.protein,
    carbs: acc.carbs + log.carbs,
    fat: acc.fat + log.fat,
    fiber: (acc.fiber || 0) + (log.fiber || 0),
    adherence: acc.adherence + (log.adherence_score || 0)
  }), { calories: 0, protein: 0, carbs: 0, fat: 0, fiber: 0, adherence: 0 });

  const days = logs.length;
  return {
    macros: {
      calories: Math.round(totals.calories / days),
      protein: Math.round(totals.protein / days),
      carbs: Math.round(totals.carbs / days),
      fat: Math.round(totals.fat / days),
      fiber: Math.round((totals.fiber || 0) / days)
    },
    adherence: Math.round(totals.adherence / days)
  };
}